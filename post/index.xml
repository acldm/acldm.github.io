<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on acldm的博客</title>
    <link>/post/</link>
    <description>Recent content in Posts on acldm的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 20 Jun 2018 13:21:14 +0800</lastBuildDate>
    
	<atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>生成自定义分布的随机数——蒙特卡洛算法</title>
      <link>/post/mtkl/</link>
      <pubDate>Wed, 20 Jun 2018 13:21:14 +0800</pubDate>
      
      <guid>/post/mtkl/</guid>
      <description>日常使用的随机有很多需求是无法满足的。自定义分布就是普通随机生成算法所棘手的一个问题。
所谓自定义分布，比如说，有一个6面骰子，正常情况下，1~6这6个数字均匀分布在6个面。投掷骰子，这六个数字各有六分之一的机率正面朝上，这是最常见的状况。
现在，换一个6面骰子，与前一个骰子不一样的是现在的6面骰有3个面上是3，两个面上是2，剩余一个面上是1。现在，投掷这个骰子，这时正面朝上的数字的机率就不是均等的了。数字3正面朝上的机率是二分之一，数字2正面朝上的机率所三分之一。数字1正面朝上的机率是六分之一。想要得到这种自定义分布的随机数，普通的随机数生成器是形不通的。
对于这样的问题，正好有一个简单有效的算法来生成这样的随机数。它就是蒙特卡洛算法。这个算法生成两个随机数并使用以下步骤来生成一个自定义分布的数：
 选择一个随机数R1 计算R1被选中的资格P(假设P=R1) 生成新的随机数R2 如果R2小于P,则R1就是要找的随机数 如果R2大于P,丢弃R1回到第1步重新寻找  以下是该算法的实现:
function generatorNumber() while true do local n = math.random(100); local n2 = math.random(100); if n2 &amp;lt; n then return n; end end end  </description>
    </item>
    
    <item>
      <title>Perlin噪音算法初次接触</title>
      <link>/post/perlin/</link>
      <pubDate>Wed, 20 Jun 2018 13:20:20 +0800</pubDate>
      
      <guid>/post/perlin/</guid>
      <description>一个标准的随机数生成器能够产生互不关联的随机数。但是一般的随机性并不符合自然界的特征。
Perlin噪音算法就是用于生成符合自然排序的伪随机数序列。这样的算法生成的值与其相邻的值是有一定关联的。比如现实中的地形，虽然高低随机但起伏一般是连续的。没有断崖时的差距。
在Processing中内置了Perlin噪音算法的实现:noise()函数。noise()函数可以有1~3个参数，分别代表1维，2维，3维。
一维噪声 我们先来使用一维的Perlin噪音与随机数生成器各生成一张趋势图来相互比较一下:
//使用随机数生成器生成的趋势图 void setup() { size(480, 240); float prevx = 0; float prevy = 0; float x = 1; for (int i=0; i&amp;lt;width; i++) { float y = random(0, (float)height); line(prevx, prevy, x, y); prevx = x; prevy = y; x++; } }  //使用Perlin算法生成的趋势图 void setup() { size(480, 240); float prevx = 0; float prevy = 0; float x = 1; float t = 1; for (int i=0; i&amp;lt;width; i++) { float y = map(noise(t), 0, 1, 0, height); line(prevx, prevy, x, y); prevx = x; prevy = y; x++; t+=0.</description>
    </item>
    
  </channel>
</rss>